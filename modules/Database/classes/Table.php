<?php
namespace Nudlle\Module\Database;
use Nudlle\Module\Database as NDB;

abstract class Table implements \Nudlle\Iface\Table {

  const DECIMAL_MAX_INT = 131072;
  const DECIMAL_MAX_SCALE = 16383;

  private static $types = [
    NDB::SMALLINT, NDB::INT, NDB::BIGINT, NDB::DECIMAL, NDB::REAL, NDB::DOUBLE,
    NDB::CHAR, NDB::VARCHAR, NDB::TEXT, NDB::BINARY,
    NDB::DATE, NDB::DATETIME, NDB::BOOL, NDB::JSONB,
  ];

  private static $options = [
    'type', 'primary', 'auto_increment', 'unsigned', 'encrypted', 'length',
    'scale', 'empty', 'null', 'now', 'mod_rw', 'mod_rw_source', 'order',
    'order_group'
  ];

  protected static $table_name;

  /*
  [
    col_name => [
      type => string, (constant from \Nudlle\Module\Database)
      primary => bool,
      auto_increment => bool|string, (only for numeric types, only once per table)
        bool: when autogenerated by postgres or when name of the sequence follows the pattern tablename_colname_seq
        string: when created manually, fill-in the actual name of the sequence
      unsigned => bool, (only for numeric types)
      encrypted => bool, (only for BINARY)
      length => integer, (maximum length for string types, maximum number of digits before the decimal point for DECIMAL)
      scale => integer, (only for DECIMAL)
      empty => bool, (only for string types, true => string can be empty)
      null => bool, (value can not be NULL when option is not defined or false)
      now => bool, (only for DATE and DATETIME; current time as default value when true)
      mod_rw => bool, (only for VARCHAR)
      mod_rw_source => bool,
      order => bool, (only for integer types)
      order_group => [ column name, ... ],
      ... => bool, (arbitrary name of a validation type, ie. email or account)
    ],
    ...
  ]
  */
  protected static $columns;

  /*
  [
    # 1-to-1 or many-to-1 relation between this (A) and some other table (B)
    foreign_keys => [
      [
        class name for table B,
        [
          col_name (A) => col_name (B),
          ...
        ]
      ],
      ...
    ],
    # Many-to-many relation between this (A) and some other table (B) using
    # a link table (C)
    many2many => [
      [
        class name for table B,
        link table name,
        [
          col_name (A) => col_name (C),
          ...
        ],
        [
          col_name (C) => col_name (B),
          ...
        ]
      ],
      ...
    ]
  ]
  */
  protected static $relations;

  protected static $mod_rw_reserved = [];

  public function __construct() {
    self::validate();
  }

  private static function check_column($name) {
    if (!array_key_exists($name, static::$columns)) {
      throw new \Nudlle\Exception\Model("Column '$name' does not exist");
    }
  }

  final public static function has_column($name) {
    return array_key_exists($name, static::$columns);
  }

  final public static function validate() {
    if (\Nudlle\has_module('Session') && !\Nudlle\Core\Debug::DEVEL_MODE) {
      $s = new \Nudlle\Module\Session(NDB::DOMAIN);
      try {
        return $s->dget('valid_tables.'.static::$table_name);
      } catch (\Nudlle\Exception\Undefined $e) {}
    }

    $errors = [];
    $primary_cols = [];
    $order_cols = [];
    $mod_rw_cols = [];
    $mod_rw_source = false;
    $auto_increment_cols = [];

    foreach (static::$columns as $name => $options) {
      if (!array_key_exists('type', $options)) {
        $errors[] = "Option 'type' not specified for column '$name'.";
        continue;
      }

      if (!in_array($options['type'], self::$types)) {
        $errors[] = "Invalid option 'type' of column '$name'.";
        continue;
      }

      if (array_key_exists('primary', $options)) {
        if (!is_bool($options['primary'])) {
          $errors[] = "Invalid value of option 'primary' of column '$name'.";
        }

        if ($options['primary']) {
          $primary_cols[] = $name;
        }
      }

      if ($options['type'] == NDB::BIGINT && PHP_INT_SIZE < 8) {
        $errors[] = "Your system does not support bigint data type (column '$name').";
      }

      if (array_key_exists('auto_increment', $options)) {
        if (!in_array($options['type'], [ NDB::SMALLINT, NDB::INT, NDB::BIGINT ])) {
          $errors[] = "Data type of column '$name' does not allow option 'auto_increment'.";
        } elseif (is_string($options['auto_increment'])) {
          if (strlen($options['auto_increment']) == 0) {
            $errors[] = "Invalid value of option 'auto_increment' of column '$name': empty string is not allowed.";
          }
        } elseif (!is_bool($options['auto_increment'])) {
          $errors[] = "Invalid value of option 'auto_increment' of column '$name'.";
        }

        if ($options['auto_increment']) {
          $auto_increment_cols[] = $name;
          if (!array_key_exists('primary', $options) || !$options['primary']) {
            $errors[] = "Column '$name' does not allow option 'auto_increment' - only primary key does.";
          }
        }
      }

      if (array_key_exists('unsigned', $options)) {
        if (!in_array($options['type'], [ NDB::SMALLINT, NDB::INT, NDB::BIGINT, NDB::DECIMAL, NDB::REAL, NDB::DOUBLE ])) {
          $errors[] = "Data type of column '$name' does not allow option 'unsigned'.";
        } elseif (!is_bool($options['unsigned'])) {
          $errors[] = "Invalid value of option 'unsigned' of column '$name'.";
        }
      }

      if (array_key_exists('encrypted', $options)) {
        if ($options['type'] != NDB::BINARY) {
          $errors[] = "Data type of column '$name' does not allow option 'encrypted'.";
        } elseif (!is_bool($options['encrypted'])) {
          $errors[] = "Invalid value of option 'encrypted' of column '$name'.";
        }
      }

      if (array_key_exists('length', $options)) {
        if (!in_array($options['type'], [ NDB::DECIMAL, NDB::CHAR, NDB::VARCHAR ])) {
          $errors[] = "Data type of column '$name' does not support option 'length'.";
        } elseif (!is_int($options['length'])) {
          $errors[] = "Invalid value of option 'length' of column '$name'.";
        } elseif ($options['length'] < 1) {
          $errors[] = "Option 'length' of column '$name' must be a positive integer.";
        } elseif ($options['type'] == NDB::DECIMAL && $options['length'] > self::DECIMAL_MAX_INT) {
          $errors[] = "Option 'length' of column '$name' is too high (max = ".self::DECIMAL_MAX_INT.").";
        }
      }

      if (array_key_exists('scale', $options)) {
        if ($options['type'] != NDB::DECIMAL) {
          $errors[] = "Data type of column '$name' does not support option 'scale'.";
        } elseif (!is_int($options['scale'])) {
          $errors[] = "Invalid value of option 'scale' of column '$name'.";
        } elseif ($options['scale'] < 0 || $options['scale'] > self::DECIMAL_MAX_SCALE) {
          $errors[] = "Option 'scale' of column '$name' is out of bounds ($min - $max).";
        }
      }

      if (in_array($options['type'], [ NDB::DECIMAL, NDB::CHAR, NDB::VARCHAR ]) && !array_key_exists('length', $options)) {
        $errors[] = "Option 'length' missing for column '$name'.";
      }
      if ($options['type'] == NDB::DECIMAL && !array_key_exists('scale', $options)) {
        $errors[] = "Option 'scale' missing for column '$name'.";
      }

      if (array_key_exists('empty', $options)) {
        if (!in_array($options['type'], [ NDB::CHAR, NDB::VARCHAR, NDB::TEXT, NDB::BINARY ])) {
          $errors[] = "Data type of column '$name' does not allow option 'empty'.";
        } elseif (!is_bool($options['empty'])) {
          $errors[] = "Invalid value of option 'empty' of column '$name'.";
        } elseif (array_key_exists('mod_rw', $options) && $options['mod_rw']) {
          $errors[] = "Option 'empty' not allowed for column '$name' (blocked by option 'mod_rw').";
        }
      }

      if (array_key_exists('null', $options)) {
        if (!is_bool($options['null'])) {
          $errors[] = "Invalid value of option 'null' of column '$name'.";
        } elseif ($options['null']) {
          $block = null;
          foreach ([ 'primary', 'mod_rw', 'mod_rw_source', 'order' ] as $option) {
            if (array_key_exists($option, $options) && $options[$option]) {
              $block = $option;
              break;
            }
          }
          if (!is_null($block)) {
            $errors[] = "Option 'null' not allowed for column '$name' (blocked by option '$block').";
          }
        }
      }

      if (array_key_exists('now', $options)) {
        if (!in_array($options['type'], [ NDB::DATE, NDB::DATETIME ])) {
          $errors[] = "Data type of column '$name' does not allow option 'now'.";
        } elseif (!is_bool($options['now'])) {
          $errors[] = "Invalid value of option 'now' of column '$name'.";
        }
      }

      if (array_key_exists('mod_rw', $options)) {
        if (!in_array($options['type'], [ NDB::VARCHAR, NDB::TEXT ])) {
          $errors[] = "Data type of column '$name' does not allow option 'mod_rw'.";
        } elseif (!is_bool($options['mod_rw'])) {
          $errors[] = "Invalid value of option 'mod_rw' of column '$name'.";
        } elseif ($options['mod_rw']) {
          $mod_rw_cols[] = $name;
        }
      }

      if (array_key_exists('mod_rw_source', $options)) {
        if (!is_bool($options['mod_rw_source'])) {
          $errors[] = "Invalid value of option 'mod_rw_source' of column '$name'.";
        }
        $mod_rw_source = $mod_rw_source || $options['mod_rw_source'];
      }

      if (array_key_exists('mod_rw', $options) && $options['mod_rw']
          && array_key_exists('mod_rw_source', $options) && $options['mod_rw_source']) {
        $errors[] = "Both 'mod_rw' and 'mod_rw_source' options are set for column '$name'.";
      }

      if (array_key_exists('order', $options)) {
        if (!in_array($options['type'], [ NDB::SMALLINT, NDB::INT, NDB::BIGINT ])) {
          $errors[] = "Data type of column '$name' does not allow option 'order'.";
        } elseif (!is_bool($options['order'])) {
          $errors[] = "Invalid value of option 'order' of column '$name'.";
        } elseif ($options['order']) {
          $block = null;
          foreach ([ 'primary', 'null', 'mod_rw', 'mod_rw_source' ] as $option) {
            if (array_key_exists($option, static::$columns[$name]) && static::$columns[$name][$option]) {
              $block = $option;
              break;
            }
          }

          if (!is_null($block)) {
            $errors[] = "Option 'order' not allowed for column '$name' (blocked by option '$block').";
          } else {
            $order_cols[] = $name;
          }
        }
      }

      if (array_key_exists('order_group', $options)) {
        if (!array_key_exists('order', $options) || !$options['order']) {
          $errors[] = "Invalid option 'order_group' of column '$name' - not allowed without option 'order'.";
        } elseif (!is_array($options['order_group']) || empty($options['order_group'])) {
          $errors[] = "Invalid value of option 'order_group' of column '$name' - a non-empty array expected.";
        } else {
          foreach ($options['order_group'] as $column) {
            if (!array_key_exists($column, static::$columns)) {
              $errors[] = "Invalid value of option 'order_group' of column '$name' - column '$column' does not exist.";
            } else {
              foreach ([ 'empty', 'null' ] as $option) {
                if (array_key_exists($option, static::$columns[$column]) && static::$columns[$column][$option]) {
                  $errors[] = "Invalid value of option 'order_group' of column '$name' - invalid column '$column' (blocked by option '$option').";
                }
              }
            }
          }
        }
      }

      $invalid = array_diff(
        array_keys($options),
        self::$options,
        get_class_methods('Nudlle\Module\Database\Validate'),
        static::get_own_methods()
      );
      foreach ($invalid as $option) {
        $errors[] = "Invalid (unknown) option '$option' of column '$name'.";
      }
    }

    if (count($mod_rw_cols) > 1) {
      $errors[] = "Option 'mod_rw' is set for multiple columns: '".implode("', '", $mod_rw_cols)."'.";
    }
    if ($mod_rw_source && empty($mod_rw_cols)) {
      $errors[] = "Option 'mod_rw_source' is not allowed when no column has option 'mod_rw' set.";
    } elseif (!empty($mod_rw_cols) && !$mod_rw_source) {
      $errors[] = "Option 'mod_rw_source' has to be set for at least one column, when option 'mod_rw' is set.";
    }
    if (!is_array(static::$mod_rw_reserved)) {
      $errors[] = "Invalid type of variable 'mod_rw_reserved' - array expected.";
    } elseif (!empty(static::$mod_rw_reserved) && count($mod_rw_cols) == 0) {
      $errors[] = "Table does not support mod_rw - variable 'mod_rw_reserved' has to be empty.";
    }

    if (count($auto_increment_cols) > 1) {
      $errors[] = "Option 'auto_increment' is set for multiple columns: '".implode("', '", $auto_increment_cols)."'.";
    }

    if (count($order_cols) > 0 && (count($primary_cols) + count($mod_rw_cols) == 0)) {
      $errors[] = "Option 'order' is not allowed when no column has option 'primary' or 'mod_rw' set.";
    } elseif (count($order_cols) > 1) {
      $errors[] = "Option 'order' is set for multiple columns: '".implode("', '", $order_cols)."'.";
    }

    if (is_array(static::$relations) && array_key_exists('foreign_keys', static::$relations)) {
      if (!is_array(static::$relations['foreign_keys'])) {
        $errors[] = "Invalid value of foreign keys: an array expected.";
      } else {
        $i = 1;

        foreach (static::$relations['foreign_keys'] as $r) {
          $e_count = count($errors);

          if (!is_array($r) || count($r) != 2 || !is_string($r[0]) || !is_array($r[1]) || empty($r[1])) {
            $errors[] = "Invalid format of foreign key no.$i.";
          } else {
            try {
              if (!is_subclass_of($r[0], get_class())) {
                $errors[] = "Invalid foreign key no.$i - '".$r[0]."' is not a subclass of Table class.";
              } else {
                foreach ($r[1] as $colA => $colB) {
                  if (!call_user_func($r[0].'::has_column', $colB)) {
                    $errors[] = "Invalid foreign key no.$i - column '$colB' does not exist in table '".call_user_func($r[0].'::get_name')."'.";
                  } elseif (call_user_func($r[0].'::is_encrypted', $colB)) {
                    $errors[] = "Invalid foreign key no.$i - column '".call_user_func($r[0].'::get_name').".$colB' is encrypted.";
                  }
                  if (!self::has_column($colA)) {
                    $errors[] = "Invalid foreign key no.$i - column '$colA' does not exist.";
                  } elseif (self::is_encrypted($colA)) {
                    $errors[] = "Invalid foreign key no.$i - column '$colA' is encrypted.";
                  }
                }
              }
            } catch (\Nudlle\Exception\Load $e) {
              $errors[] = "Invalid foreign key no.$i - class '".$r[0]."' does not exist.";
            }
          }

          if ($e_count == count($errors)) {
            $primary = call_user_func($r[0].'::get_primary', true);
            $key = array_unique(array_values($r[1]));
            if (count($key) != count($primary) || count(array_diff($key, $primary)) > 0) {
              $errors[] = "Invalid foreign key no.$i - the key does not match the primary key of the referred table.";
            }
          }

          $i++;
        }
      }
    }

    if (is_array(static::$relations) && array_key_exists('many2many', static::$relations)) {
      if (!is_array(static::$relations['many2many'])) {
        $errors[] = "Invalid value of many-to-many relations: an array expected.";
      } else {
        $i = 1;

        foreach (static::$relations['many2many'] as $r) {
          if (!is_array($r) || count($r) != 4 || !is_string($r[0]) || !is_string($r[1])
              || !is_array($r[2]) || !is_array($r[3]) || empty($r[2]) || empty($r[3])) {
            $errors[] = "Invalid format of many-to-many relation no.$i.";
          } else {
            try {
              if (!is_subclass_of($r[0], get_class())) {
                $errors[] = "Invalid many-to-many relation no.$i - '".$r[0]."' is not a subclass of Table class.";
              } else {
                $OK = true;

                foreach ($r[3] as $col_name) {
                  if (!call_user_func($r[0].'::has_column', $col_name)) {
                    $errors[] = "Invalid many-to-many relation no.$i - column '$col_name' does not exist in table '".call_user_func($r[0].'::get_name')."'.";
                    $OK = false;
                  } elseif (call_user_func($r[0].'::is_encrypted', $col_name)) {
                    $errors[] = "Invalid many-to-many relation no.$i - column '".call_user_func($r[0].'::get_name').".$col_name' is encrypted.";
                    $OK = false;
                  }
                }

                if ($OK) {
                  $primary = call_user_func($r[0].'::get_primary', true);
                  $key = array_unique(array_values($r[3]));
                  if (count($key) != count($primary) || count(array_diff($key, $primary)) > 0) {
                    $errors[] = "Invalid many-to-many relation no.$i - the relation does not match the primary key of the referred table.";
                  }
                }
              }
            } catch (\Nudlle\Exception\Load $e) {
              $errors[] = "Invalid many-to-many relation no.$i - class '".$r[0]."' does not exist.";
            }

            if (strlen($r[1]) == 0) {
              $errors[] = "Invalid many-to-many relation no.$i - link table name is empty.";
            }

            $OK = true;
            foreach (array_keys($r[2]) as $col_name) {
              if (!self::has_column($col_name)) {
                $errors[] = "Invalid many-to-many relation no.$i - column '$col_name' does not exist.";
                $OK = false;
              } elseif (self::is_encrypted($col_name)) {
                $errors[] = "Invalid many-to-many relation no.$i - column '$col_name' is encrypted.";
                $OK = false;
              }
            }

            if ($OK) {
              $key = array_keys($r[2]);
              if (count($key) != count($primary_cols) || count(array_diff($key, $primary_cols)) > 0) {
                $errors[] = "Invalid many-to-many relation no.$i - the relation does not match the primary key.";
              }
            }
          }

          $i++;
        }
      }
    }

    $ok = empty($errors);
    if (isset($s)) {
      $s->dset('valid_tables.'.static::$table_name, $ok);
    }
    if (!$ok) {
      throw new \Nudlle\Exception\Model(implode("\n", $errors));
    }
  }

  public static function get_name() {
    return static::$table_name;
  }

  public static function get_columns() {
    return array_keys(static::$columns);
  }

  private static function get_column_by_option($option, $force_array = false) {
    if (!in_array($option, self::$options)) {
      throw new \Nudlle\Exception\App("Invalid option '$option'.");
    }

    $list = [];
    foreach (static::$columns as $name => $options) {
      if (array_key_exists($option, $options) && $options[$option]) {
        $list[] = $name;
      }
    }

    if ($force_array) {
      return $list;
    }

    if (count($list) > 1) {
      return $list;
    } elseif (count($list) == 1) {
      return $list[0];
    } else {
      return null;
    }
  }

  public static function get_primary($force_array = false) {
    return self::get_column_by_option('primary', $force_array);
  }

  public static function get_mod_rw() {
    return self::get_column_by_option('mod_rw');
  }

  public static function get_auto_increment($with_seq_name = false) {
    $column = self::get_column_by_option('auto_increment');

    if ($column === null) {
      return null;
    } elseif ($with_seq_name) {
      $value = static::$columns[$column]['auto_increment'];
      $seq_name = is_string($value) ? $value : static::$table_name.'_'.$column.'_seq';
      return [ $column, $seq_name ];
    } else {
      return $column;
    }
  }

  public static function get_order() {
    return self::get_column_by_option('order');
  }

  public static function get_semantic_options($column) {
    self::check_column($column);

    return array_diff(array_keys(static::$columns[$column]), self::$options);
  }

  private static function get_option($column, $option, $fallback = false) {
    self::check_column($column);

    if (!array_key_exists($option, static::$columns[$column])) {
      return $fallback;
    } else {
      return static::$columns[$column][$option];
    }
  }

  public static function get_type($column) {
    return self::get_option($column, 'type', null);
  }

  public static function is_primary($column) {
    return self::get_option($column, 'primary');
  }

  public static function is_auto_increment($column) {
    return self::get_option($column, 'auto_increment') ? true : false;
  }

  public static function is_encrypted($column) {
    return self::get_option($column, 'encrypted');
  }

  public static function is_unsigned($column) {
    return self::get_option($column, 'unsigned');
  }

  public static function get_length($column) {
    return self::get_option($column, 'length', null);
  }

  public static function get_scale($column) {
    return self::get_option($column, 'scale', null);
  }

  public static function is_empty($column) {
    return self::get_option($column, 'empty');
  }

  public static function is_null($column) {
    return self::get_option($column, 'null');
  }

  public static function is_now($column) {
    return self::get_option($column, 'now');
  }

  public static function is_mod_rw($column) {
    return self::get_option($column, 'mod_rw');
  }

  public static function is_mod_rw_source($column) {
    return self::get_option($column, 'mod_rw_source');
  }

  public static function is_order($column) {
    return self::get_option($column, 'order');
  }

  public static function get_order_group() {
    $column = self::get_order();
    if (is_null($column)) {
      return [];
    } else {
      return self::get_option($column, 'order_group', []);
    }
  }

  private static function get_relation($table, $type) {
    if (!array_key_exists($type, static::$relations) || empty(static::$relations[$type])) {
      return null;
    }
    if (is_null($table)) return static::$relations[$type];

    foreach (static::$relations[$type] as $r) {
      if (call_user_func($r[0].'::get_name') == $table) return $r;
    }
    return null;
  }

  public static function get_foreign_key($table = null) {
    return self::get_relation($table, 'foreign_keys');
  }

  public static function get_many2many($table = null) {
    return self::get_relation($table, 'many2many');
  }

  public static function get_mod_rw_reserved() {
    return static::$mod_rw_reserved;
  }

  public static function get_own_methods() {
    $rf_called = new \ReflectionClass(get_called_class());
    $rf_self = new \ReflectionClass(get_class());

    $methods = array_intersect(
      $rf_called->getMethods(\ReflectionMethod::IS_STATIC),
      $rf_called->getMethods(\ReflectionMethod::IS_PUBLIC)
    );
    $own_methods = [];

    foreach ($methods as $m) {
      if (!$rf_self->hasMethod($m->getName())) {
        $own_methods[] = $m->getName();
      }
    }

    return $own_methods;
  }

  public static function postprocess_row(&$row) {
    foreach ($row as $column => &$value) {
      self::check_column($column);
      $type = static::$columns[$column]['type'];

      if ($type == NDB::BINARY) {
        $value = stream_get_contents($value);
        $value = hex2bin($value);
        if (self::is_encrypted($column)) {
          $value = NDB::decrypt($value);
        }
      } elseif (in_array($type, [ NDB::DATE, NDB::DATETIME ])) {
        $value = new \DateTime($value);
      } elseif ($type == NDB::JSONB) {
        $value = json_decode($value, true);
        $err = json_last_error();
        if ($err != JSON_ERROR_NONE) {
          throw new \Nuddle\Exception\Consistency("Invalid JSON, decoding failed:".json_last_error_msg(), false, $err);
        }
      }
    }
  }

  public static function preprocess_data($column, $value) {
    $type = self::get_type($column);

    if ($type == NDB::DATE || $type == NDB::DATETIME) {
      return $value->format($type == NDB::DATE ? NDB::DATE_FORMAT : NDB::DATETIME_FORMAT);
    } elseif ($type == NDB::BINARY) {
      if (self::is_encrypted($column)) {
        $value = NDB::encrypt($value);
      }
      return bin2hex($value);
    } elseif ($type == NDB::JSONB) {
      $value = json_encode($value, JSON_HEX_APOS & JSON_UNESCAPED_UNICODE);
      $err = json_last_error();
      if ($err != JSON_ERROR_NONE) {
        throw new \Nudlle\Exception\WrongData("Can not encode to JSON: ".json_last_error_msg(), false, $err);
      }
      return $value;
    } else {
      return $value;
    }
  }

}

?>
